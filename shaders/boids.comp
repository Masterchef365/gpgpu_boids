#version 450
layout (local_size_x = 16) in;

struct Boid {
    vec3 pos;
    uint _pad0;
    vec3 heading;
    uint _pad1;
};

layout(std430, binding = 0) readonly buffer Read {
    Boid read[];
};

layout(std430, binding = 1) buffer Write {
    Boid write[];
};

const uint downsample = 1;
const float speed = 0.04;
const float dist_thresh = 5.;
const float cohere = 0.5;
const float steer = 0.2;
const float parallel = 0.2;

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= read.length()) return;

    Boid boid = read[gid];
    vec3 avg_off = vec3(0);
    vec3 avg_heading = vec3(0);
    float avg_dist = 0.;
    uint total = 0;

    uint width = read.length() / downsample;
    uint start = width * (int(gid * boid.pos.x * 90.) % downsample);
    for (uint i = start; i < start + width; i += 1) {
        if (gid == i) {
            continue;
        }
        Boid other = read[i];
        vec3 off = boid.pos - other.pos;
        float dist = length(off);
        if (dist < dist_thresh) {
            avg_off += normalize(off);
            avg_heading += normalize(other.heading);
            avg_dist += dist;
            total += 1;
        }
    }

    if (total > 0) {
        avg_off = normalize(avg_off);
        avg_heading = normalize(avg_heading);
        avg_dist /= float(total);

        //float cohere_factor = clamp(cohere - avg_dist, 0., 1.);
        vec3 away = cross(boid.heading, avg_off);
        vec3 cohere_head = mix(-avg_off, away, cohere);

        vec3 new_heading = normalize(
            boid.heading + 
            cohere_head * steer +
            avg_heading * parallel
        );

        if (!any(isnan(new_heading))) {
            write[gid].heading = new_heading;
        } else {
            write[gid].heading = read[gid].heading;
        }
    } else {
        write[gid].heading = read[gid].heading;
    }

    //write[gid].heading = boid.heading;
    write[gid].pos = boid.pos + write[gid].heading * speed;
}
