#version 450
layout (local_size_x = 16) in;

struct Boid {
    vec3 pos;
    uint unused0;
    vec3 heading;
    uint unused1;
};

layout(std430, binding = 0) readonly buffer Read {
    Boid read[];
};

layout(std430, binding = 1) buffer Write {
    Boid write[];
};

layout(std430, push_constant) uniform Params {
    uint downsample;
    float speed; // 0.004
    float dist_thresh; // 5.0
    float cohere; // 0.5
    float steer; // 0.12
    float parallel; // 0.12
};

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= read.length()) return;

    Boid boid = read[gid];
    vec3 avg_off = vec3(0);
    vec3 avg_heading = vec3(0);
    float avg_dist = 0.;
    uint total = 0;
    for (uint i = int(gid * boid.pos.x * 90.) % downsample; i < read.length(); i += downsample) {
        if (gid == i) {
            continue;
        }
        Boid other = read[i];
        vec3 off = boid.pos - other.pos;
        float dist = length(off);
        if (dist < dist_thresh) {
            avg_off += normalize(off);
            avg_heading += normalize(other.heading);
            avg_dist += dist;
            total += 1;
        }
    }

    if (total > 0) {
        avg_off = normalize(avg_off);
        avg_heading = normalize(avg_heading);
        avg_dist /= float(total);

        //float cohere_factor = clamp(cohere - avg_dist, 0., 1.);
        vec3 away = cross(boid.heading, avg_off);
        vec3 cohere_head = mix(-avg_off, away, cohere);

        vec3 new_heading = normalize(
            boid.heading + 
            cohere_head * steer +
            avg_heading * parallel
        );

        if (!any(isnan(new_heading))) {
            write[gid].heading = new_heading;
        } else {
            write[gid].heading = read[gid].heading;
        }
    } else {
        write[gid].heading = read[gid].heading;
    }

    write[gid].pos = boid.pos + write[gid].heading * speed;
}


